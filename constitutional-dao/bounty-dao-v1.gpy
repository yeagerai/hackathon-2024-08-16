import json
from datetime import datetime
from backend.node.genvm.icontract import IContract
from backend.node.genvm.equivalence_principle import call_llm_with_principle


class GenLayerDAO(IContract):
    def __init__(self):

        self.total_supply = 1000
        self.token_supply = self.total_supply
        self.balances = {}

        self.constitution = [
            "This Constitution describes the decision-making framework for GenLayerDAO governance.",
            "The following process governs the rules and procedures by which GenLayerDAO may propose, vote on, and implement Bounty Programs.",
            "GenLayerDAOâ€™s purpose is to grow the GenLayer Blockchain by rewarding Bounty Program contributors with tokens.",
            "An address must hold at least one token to be a member of the DAO.",  
            "Only members of the GenLayerDAO can propose new Bounty Programs.",
            "Bounty programs must follow be in line with one of the following goals:",
            "- Increase Brand Awareness for the GenLayer Blockchain or one of the applications built on top of GenLayer.",
            "- Lead to Code Contributions to the GenLayer Repository on GitHub.",
            "- Lead to applications built on top of GenLayer.",
            "- Empower initiatives that help to build or enhance the community around GenLayer, such as meetups, hackathons, or online forums.",
            "If a Bounty program proposal does not help any of the listed goals, reject the proposal.",
            "Bounty programs must be unique. If a new bounty program proposal is the same as an existing proposed or active bounty, reject the proposal."
            "If a bounty program proposal meets the criteria, it is added to proposed bounties for a vote.",
            "A bounty program proposal has to be approved by a majority vote.",
            "The voting power of a member is proportional to the number of tokens a member holds.",
            "At least one-third of all votable tokens must participate in the voting process; otherwise, the proposal will be rejected",
            "A majority of those participating votable tokens must agree for the proposal to be accepted",        
            "Once a bounty program is approved, it is moved to the active bounty list",
            "Anyone can try to claim the reward of an active bounty, according to the rules of the bounty.",
            "A user does not have to be a member of the DAO or hold any DAO tokens to claim the bounty",
        ]
       
        self.state = f"""
{{
    "proposed_bounties": [],
    "active_bounties": [],
}}
"""

    async def execute_motion(self, motion: str) -> None:
        prompt = f"""
You are GenLayerDAO.

GenLayerDAO has a constitution:
{ json.dumps(self.constitution) } 

GenLayerDAO has a token.
The total supply of the token is: {self.total_supply}
The available supply of the token you still hold is: {self.token_supply}

Current date and time is:
{ datetime.now() }

Your current state is as follows:
{ self.state } 

User with the address "{ contract_runner.from_address }"
has made the following motion:
{ motion }

The balance of the user is:
{ self.get_balance_of(contract_runner.from_address) } 


You must decide whether to accept the motion.

You must respond with the following JSON format:
{{
"constitution_rules_check": array<str>, // List every rule of the constitution, along with a YES or NO indicating whether the proposed motion is in line with this rule
"reasoning": str,       // Your reasoning - only accept the motion if it doesn't break any rules
"motion_accepted": bool // true or false - decision to accept or reject the motion
}}

It is mandatory that you respond only using the JSON format above,
nothing else. Don't include any other words or characters,
your output must be only JSON without any formatting prefix or suffix.
This result should be perfectly parseable by a JSON parser without errors.
"""

        result = await call_llm_with_principle(
            prompt,
            eq_principle="motion_accepted has to match exactly.",
        )
        print(result)
        output = self.get_decode_json_resilient(result)

        if not (output["motion_accepted"]):
            return "Motion Rejected, reasoning: " + output["reasoning"]

        prompt = f"""
You are GenLayerDAO.

GenLayerDAO has a constitution:
{ json.dumps(self.constitution) } 

GenLayerDAO has a token.
The total supply of the token is: {self.total_supply}
The available supply of the token you still hold is: {self.token_supply}

Current date and time is:
{ datetime.now() }

Your current state is as follows:
{ self.state } 

User with the address "{ contract_runner.from_address }"
has made the following motion:
{ motion }

The balance of the user is:
{ self.get_balance_of(contract_runner.from_address) } 


You have already decided to accept the motion in an earlier step.
You must now decide how the motion is implemented.
Look at your current state, and propose a new updated state, as well as any token transfers needed to implement the motion.

You must respond with the following JSON format:
{{
"reasoning": str,       // Your reasoning - explain in detail what state changes and token transfers will need to happen
"updated_state": any,      // Your updated state after the motion has been applied
"token_transfers": object<address, int> // Address and amount pairs that specify how many tokens to transfer to what addresses, for example as rewards for bounties.
}}

It is mandatory that you respond only using the JSON format above,
nothing else. Don't include any other words or characters,
your output must be only JSON without any formatting prefix or suffix.
This result should be perfectly parseable by a JSON parser without errors.
        """

        result = await call_llm_with_principle(
            prompt,
            eq_principle="The updated state has to be essentially equivalent. The token transfers have to be equivalent.",
        )
        print(result)
        output = self.get_decode_json_resilient(result)

        # Token transfers
        for address, amount in output["token_transfers"].items():
            self.send_tokens(amount, address)

        self.state = json.dumps(output["updated_state"])


    def buy_tokens(self, amount: int):
        # Placeholder method to get free tokens
        self.send_tokens(amount, contract_runner.from_address)

    def send_tokens(self, amount: int, holder: str):
        # Unsafe, should be internal only
        if holder in self.balances:
            self.balances[holder] += amount
        else:
            self.balances[holder] = amount
        self.token_supply -= amount

    def get_balances(self) -> dict[str, int]:
        return self.balances

    def get_balance_of(self, address: str) -> int:
        return self.balances.get(address, 0)

    def get_state(self) -> str:
        return self.state

    def get_decode_json_resilient(self, s: str) -> dict:
        clean = self.get_extract_json_from_string(s).replace("True", "true").replace("False", "false")
        return json.loads(clean)

    def get_extract_json_from_string(self, s: str) -> str:
        # Use regex to find the first and last curly brackets in the string
        start_index = s.find('{')
        end_index = s.rfind('}')

        if start_index != -1 and end_index != -1 and start_index < end_index:
            return s[start_index:end_index + 1]
        else:
            # No curly brackets found
            return ""