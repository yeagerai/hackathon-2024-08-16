from dataclasses import dataclass
from typing import List
from backend.node.genvm.icontract import IContract
from backend.node.genvm.equivalence_principle import EquivalencePrinciple
import json


@dataclass
class AnalyzedTweet:
    influencer: str
    tweet: str
    date: str
    cryptocurrency: str
    positive_sentiment: float


# TODO: handle duplication of tweet feeds
class TowelTechies(IContract):
    def __init__(self) -> None:
        from collections import defaultdict
        self.leaderboard: dict[str, float] = {}
        self.price_history: dict[str, dict[str, float]] = defaultdict(dict)
        self.tweets_pending_process: List[AnalyzedTweet] = []
        self.balances : dict[]= {}

    async def feed(self, influencer: str, tweet: str, date: str):
        """
        Inputs:
        - influencer: the name of the influencer
        - tweet: the tweet content
        - date: the date of the tweet

        Process:
        1. Analyze the tweet to determine if sentiment is positive towards one or more cryptocurrencies
            - This step uses Consensus to analyze the tweet
            - We save these results in a list of tweets pending process, one per cryptocurrency
        """
        if influencer not in self.leaderboard:  # influencer enters the leaderboard
            self.leaderboard[influencer] = 0

        tweet_result = {}
        async with EquivalencePrinciple(
            result=tweet_result,
            principle="The cryptocurrencies names are the exact same, and the positive_senitment is similar",
            comparative=True,
        ) as eq:
            # TODO: actually retrieve from the internet
            # web_data = await eq.get_webpage(tweet)
            # print(web_data)
            web_data = tweet

            task = f"""In this webpage you'll find a tweet from a crypto influencer. 
            Analyze this tweet to determine if sentiment is positive towards one or more cryptocurrencies
            
            Return the output as a JSON array of cryptocurrencies and their positive sentiment.
            - 'positive_sentiment' should go from -1 to 1.
            - 'cryptocurrency' should be the entire name of the cryptocurrency, all in lowercase, only letters

            Here's an example format:
            [
              {{
                "cryptocurrency": "bitcoin",
                "positive_sentiment": 0.1
              }}
            ]

            Respong ONLY with the JSON output, nothing else. The output should be parsable by any JSON parser

            Web page content:
            {web_data}
            """
            result = await eq.call_llm(task)
            print(result)
            eq.set(result)

        tweet_result = json.loads(tweet_result["output"])

        for item in tweet_result:
            tweet_pending_process = AnalyzedTweet(
                influencer=influencer,
                tweet=tweet,
                date=date,
                cryptocurrency=item["cryptocurrency"],
                positive_sentiment=item["positive_sentiment"],
            )

            self.tweets_pending_process.append(tweet_pending_process)

    async def process_score(self):
        """
        1. For each analyzed tweet, get the daily price change of the cryptocurrency
            - This step uses Consensus and connects to the Internet to get the price change
        2. Update the leaderboard with the score of the influencer, based on alignment between sentiment and price change
        """
        for tweet in self.tweets_pending_process:
            price_change = await self.retrieve_market_data(
                tweet.cryptocurrency, tweet.date
            )

            # This is a simple score function for demonstration
            self.leaderboard[tweet.influencer] += (
                price_change * tweet.positive_sentiment
            )

        self.tweets_pending_process = []

    # TODO: use date
    async def retrieve_market_data(self, cryptocurrency: str, date: str) -> float:
        if cryptocurrency in self.price_history:
            if date in self.price_history[cryptocurrency]:
                return self.price_history[cryptocurrency][date]

        market_result = {}

        async with EquivalencePrinciple(
            result=market_result,
            principle="The price ",
            comparative=True,
        ) as eq:
            url = "https://coinmarketcap.com/currencies/" + cryptocurrency
            web_data = await eq.get_webpage(url)
            print(web_data)

            task = f"""In this webpage from 'coinmarketcap' you'll find a lot of information about the market status of a cryptocurrency. 
                Analyze this information to determine today's daily price change of the cryptocurrency.
                
                Return the output as a JSON number bigger than -100, representing the daily price change.
                - Negative numbers mean that the price went down
                - Positive numbers mean that the price went up

                Respong ONLY with the JSON output, nothing else, not even the word "json". The output should be parsable by any JSON parser
                Example output:
                {{
                  "price_change": 2.4
                }}

                Web page content:
                {web_data}
                """
            result = await eq.call_llm(task)
            print(result)
            eq.set(result)

        market_data = json.loads(market_result["output"])["price_change"]
        self.price_history[cryptocurrency][date] = market_data
        return market_data

    # Read methods
    def get_leaderboard(self):
        return self.leaderboard

    def get_price_history(self):
        return self.price_history

    def get_tweets_pending_process(self):
        return self.tweets_pending_process

    async def test(self):
        await self.feed(
            "Chris Burniske",
            """
        Each cycle I've tended to give a majority of focus to one major underdog. In 2014-17 that was $BTC, in 2018-2021 that was $ETH, and in 2022 to now that's $SOL.
        """,
            "2024-08-15",
        )

        await self.process_score()
